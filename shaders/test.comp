#version 430 core
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#define PI 3.14159265
const float EPSILON = 0.0000001;

layout (std140, binding = 0) uniform Matrices
{
	mat4 projection;
	mat4 view;
};

layout (rgba32f) uniform image2D imgOutput;

layout(std430, binding = 1) buffer VertexData
{
    int amount;
    float vertexData[];
};

struct Ray
{
    vec3 origin;
    vec3 direction;
};

uniform int samplesPerPixel;

uniform vec3 cameraPos;
uniform vec3 lookAt;
uniform float nearPlane;

uniform sampler2D backgroundImage;

bool Intersects(out vec3 intersection, Ray ray, vec3 vertex0, vec3 vertex1, vec3 vertex2);

void main() 
{
    ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imgSize = imageSize(imgOutput);

    float x = uv.x / imgSize.x;
    float y = uv.y / imgSize.y;
    vec2 pixelCoor = vec2(x, y);
    //vec2 ndcCoor = uv / imgSize * 2 - 1;

    Ray ray;
    ray.origin = cameraPos;
    ray.direction = lookAt;
    for (int i = 0; i < amount; i += 24)
    {
        vec3 v1 = vec3(vertexData[i], vertexData[i + 1], vertexData[i + 2]);
        vec3 v2 = vec3(vertexData[i + 8], vertexData[i + 9], vertexData[i + 10]);
        vec3 v3 = vec3(vertexData[i + 16], vertexData[i + 17], vertexData[i + 18]);

        vec3 intersection;
        bool success = Intersects(intersection, ray, v1, v2, v3);
        if (success)
        {
            imageStore(imgOutput, uv, vec4(0, 1, 0, 1));
        }
        else
        imageStore(imgOutput, uv, vec4(0, 0, 0, 1));
    }
}

bool Intersects(out vec3 intersection, Ray ray, vec3 vertex0, vec3 vertex1, vec3 vertex2)
{
    vec3 edge0 = vertex1 - vertex0;
    vec3 edge1 = vertex2 - vertex0;

    vec3 h = cross(ray.direction, edge1);
    float a = dot(edge0, h);

    if (a > -EPSILON && a < EPSILON)
    {
        intersection = vec3(0);
        return false;
    }
    float f = 1 / a;
    vec3 s = ray.origin - vertex0;
    float u = f * dot(s, h);

    if (u < 0 || u > 1)
    {
        intersection = vec3(0);
        return false;
    }

    vec3 q = cross(s, edge0);
    float v = f * dot(ray.direction, q);

    if (v < 0 || v > 1)
    {
        //intersection = vec3(0);
        return false;
    }

    float t = f * dot(edge1, q);
    if (t > EPSILON)
    {
        intersection = ray.origin + ray.direction * t;
        return true;
    }
    else
    {
        intersection = vec3(0);
        return false;
    }
}